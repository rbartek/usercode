// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.0.7         [262151]
ROOT Release   : 5.27/06       [334598]
Creator        : wilken
Date           : Fri Jul 27 06:44:02 2012
Host           : Linux lxbuild051.cern.ch 2.6.18-238.1.1.el5 #1 SMP Wed Jan 19 11:06:36 CET 2011 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/hep/wilken/taus/CMSSW_4_4_2_patch8/src/UserCode/wilken/TMVA
Training events: 2900
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
BoostType: "AdaBoost" [Boosting type for the trees in the forest]
AdaBoostBeta: "3.000000e-01" [Parameter for AdaBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "100" [Minimum number of events required in a leaf node (default: max(20, N_train/(Nvar^2)/10) ) ]
nCuts: "35" [Number of steps during node cut optimisation]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
MaxDepth: "3" [Max depth of the decision tree allowed]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
Shrinkage: "1.000000e+00" [Learning rate for GradBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "4" [Number of variables used if randomised tree option is chosen]
UseNTrainEvents: "2900" [number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
PruneStrength: "-1.000000e+00" [Pruning strength]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
NNodesMax: "100000" [Max number of nodes in tree]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 12
Hmass                         Hmass                         Hmass                         H Mass                        GeV                               'F'    [80.0143203735,149.9921875]
CSV0                          CSV0                          CSV0                          CSV 1                                                           'F'    [0.500022113323,1]
Emumass                       Emumass                       Emumass                       Emumass                       GeV                               'F'    [10.2493448257,69.9997329712]
DeltaPhiHV                    DeltaPhiHV                    DeltaPhiHV                    DeltaPhiHV                                                      'F'    [2.00042819977,3.14145445824]
Mt                            Mt                            Mt                            Mt                                                              'F'    [1.2634884119,341.267242432]
dPhiHMET                      dPhiHMET                      dPhiHMET                      dPhiHMET                                                        'F'    [1.04635882378,3.14140701294]
abs(Dphiemu)                  dphiEMU                       dphiEMU                       Dphiemu                                                         'F'    [0.000684682279825,3.14013767242]
abs(DphiZMET)                 dphiZMET                      dphiZMET                      DphiZMET                                                        'F'    [0.000695943832397,1.24840211868]
PtbalMETH                     PtbalMETH                     PtbalMETH                     PtbalMETH                                                       'F'    [-86.774848938,284.043487549]
EtaStandDev                   EtaStandDev                   EtaStandDev                   EtaStandDev                                                     'F'    [0.0361718423665,1.84112560749]
jetCHF0                       jetCHF0                       jetCHF0                       jetCHF0                                                         'F'    [0.0106167662889,1.00000011921]
ProjVisT                      ProjVisT                      ProjVisT                      ProjVisT                                                        'F'    [0.0357572138309,233.421295166]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#ifndef NN
#define NN new BDT_DecisionTreeNode
#endif
   
#ifndef BDT_DecisionTreeNode__def
#define BDT_DecisionTreeNode__def
   
class BDT_DecisionTreeNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDT_DecisionTreeNode ( BDT_DecisionTreeNode* left,
                          BDT_DecisionTreeNode* right,
                          double cutValue, Bool_t cutType, int selector,
                          int nodeType, double purity, double response ) :
   fLeft    ( left     ),
   fRight   ( right    ),
   fCutValue( cutValue ),
   fCutType ( cutType  ),
   fSelector( selector ),
   fNodeType( nodeType ),
   fPurity  ( purity   ),
   fResponse( response ){}

   virtual ~BDT_DecisionTreeNode();

   // test event if it decends the tree at this node to the right
   virtual Bool_t GoesRight( const std::vector<double>& inputValues ) const;
   BDT_DecisionTreeNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual Bool_t GoesLeft ( const std::vector<double>& inputValues ) const;
   BDT_DecisionTreeNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDT_DecisionTreeNode*   fLeft;     // pointer to the left daughter node
   BDT_DecisionTreeNode*   fRight;    // pointer to the right daughter node
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   Bool_t                  fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fSelector; // index of variable used in node selection (decision tree)   
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
BDT_DecisionTreeNode::~BDT_DecisionTreeNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
Bool_t BDT_DecisionTreeNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   Bool_t result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
Bool_t BDT_DecisionTreeNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   Bool_t IsStatusClean() const { return fStatusIsClean; }

 protected:

   Bool_t fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 12 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "Hmass", "CSV0", "Emumass", "DeltaPhiHV", "Mt", "dPhiHMET", "abs(Dphiemu)", "abs(DphiZMET)", "PtbalMETH", "EtaStandDev", "jetCHF0", "ProjVisT" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 80.0143203735352;
      fVmax[0] = 149.9921875;
      fVmin[1] = 0.500022113323212;
      fVmax[1] = 1;
      fVmin[2] = 10.2493448257446;
      fVmax[2] = 69.9997329711914;
      fVmin[3] = 2.00042819976807;
      fVmax[3] = 3.14145445823669;
      fVmin[4] = 1.26348841190338;
      fVmax[4] = 341.267242431641;
      fVmin[5] = 1.04635882377625;
      fVmax[5] = 3.14140701293945;
      fVmin[6] = 0.000684682279825211;
      fVmax[6] = 3.14013767242432;
      fVmin[7] = 0.000695943832397461;
      fVmax[7] = 1.24840211868286;
      fVmin[8] = -86.7748489379883;
      fVmax[8] = 284.043487548828;
      fVmin[9] = 0.036171842366457;
      fVmax[9] = 1.84112560749054;
      fVmin[10] = 0.0106167662888765;
      fVmax[10] = 1.00000011920929;
      fVmin[11] = 0.0357572138309479;
      fVmax[11] = 233.421295166016;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const Bool_t fIsNormalised;
   Bool_t IsNormalised() const { return fIsNormalised; }
   double fVmin[12];
   double fVmax[12];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[12];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDT_DecisionTreeNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDT_DecisionTreeNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDT_DecisionTreeNode*)current->GetRight();
         else current=(BDT_DecisionTreeNode*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(2.26136129201249);
  fForest.push_back( 
NN(
0, 
0, 
0.277964, 1, -1, -1, 0.000532247,-99)    );
  // itree = 1
  fBoostWeights.push_back(1.58295);
  fForest.push_back( 
NN(
0, 
0, 
0.277964, 1, -1, -1, 0.00508425,-99)    );
  // itree = 2
  fBoostWeights.push_back(1.10807);
  fForest.push_back( 
NN(
0, 
0, 
0.277964, 1, -1, -1, 0.0242792,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.775647);
  fForest.push_back( 
NN(
0, 
0, 
0.277964, 1, -1, -1, 0.0700781,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.580273);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.618698,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.282201,-99) , 
3.02869, 0, 5, 0, 0.405422,-99) , 
NN(
0, 
0, 
1.30429, 1, -1, -1, 0.0989305,-99) , 
46.6962, 1, 2, 0, 0.254966,-99) , 
NN(
0, 
0, 
56.7227, 1, -1, -1, 0.0856659,-99) , 
0.277964, 1, 7, 0, 0.140657,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.412564);
  fForest.push_back( 
NN(
0, 
0, 
56.7219, 1, -1, -1, 0.201779,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.343999);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.571592,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.306236,-99) , 
0.618045, 1, 9, 0, 0.464783,-99) , 
NN(
0, 
0, 
86.957, 1, -1, -1, 0.207532,-99) , 
0.451104, 1, 7, 0, 0.348786,-99) , 
NN(
0, 
0, 
53.7916, 0, -1, -1, 0.0586031,-99) , 
56.7219, 1, 2, 0, 0.276348,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.251154);
  fForest.push_back( 
NN(
0, 
0, 
58.3816, 1, -1, -1, 0.302129,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.253195);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.562085,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.250296,-99) , 
124.723, 1, 0, 0, 0.502713,-99) , 
NN(
0, 
0, 
37.8275, 1, -1, -1, 0.241586,-99) , 
2.72894, 0, 3, 0, 0.425187,-99) , 
NN(
0, 
0, 
53.7916, 0, -1, -1, 0.079495,-99) , 
58.3816, 1, 2, 0, 0.357547,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.206097);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.520007,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.188673,-99) , 
0.736123, 0, 1, 0, 0.46575,-99) , 
NN(
0, 
0, 
1.13681, 0, -1, -1, 0.239079,-99) , 
0.728278, 1, 7, 0, 0.417806,-99) , 
NN(
0, 
0, 
53.7916, 0, -1, -1, 0.118321,-99) , 
56.7219, 1, 2, 0, 0.355608,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.188154);
  fForest.push_back( 
NN(
0, 
0, 
58.3816, 1, -1, -1, 0.34815,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.171033);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.524162,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.206021,-99) , 
2.00645, 1, 6, 0, 0.479509,-99) , 
NN(
0, 
0, 
34.6583, 1, -1, -1, 0.257937,-99) , 
2.57062, 0, 3, 0, 0.44227,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.525673,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
0.958806, 0, 1, 0, 0.37073,-99) , 
NN(
0, 
0, 
1.79178, 1, -1, -1, 0.0300853,-99) , 
53.7916, 0, 11, 0, 0.141634,-99) , 
58.3816, 1, 2, 0, 0.391973,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.183069);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.533568,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.360681,-99) , 
98.6348, 0, 0, 0, 0.457767,-99) , 
NN(
0, 
0, 
0.173759, 1, -1, -1, 0.273534,-99) , 
124.723, 1, 0, 0, 0.422697,-99) , 
NN(
0, 
0, 
53.7916, 0, -1, -1, 0.141972,-99) , 
58.3816, 1, 2, 0, 0.377631,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.212397);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.582659,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.406065,-99) , 
51.0346, 0, 8, 0, 0.50606,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.57895,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.28011,-99) , 
35.3659, 1, 11, 0, 0.356627,-99) , 
2.95054, 0, 3, 0, 0.421686,-99) , 
NN(
0, 
0, 
52.0588, 1, -1, -1, 0.142949,-99) , 
2.26807, 1, 6, 0, 0.385333,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.17478);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.584471,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.251908,-99) , 
31.5925, 0, 2, 0, 0.543095,-99) , 
NN(
0, 
0, 
43.847, 0, -1, -1, 0.395305,-99) , 
58.1514, 1, 4, 0, 0.439437,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.53433,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
0.958806, 0, 1, 0, 0.396931,-99) , 
NN(
0, 
0, 
1.79178, 1, -1, -1, 0.0405165,-99) , 
53.7916, 0, 11, 0, 0.168002,-99) , 
58.3816, 1, 2, 0, 0.398606,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.136363);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.522322,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.249357,-99) , 
2.00645, 1, 6, 0, 0.486866,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.507185,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.111337,-99) , 
34.6583, 1, 11, 0, 0.310667,-99) , 
2.57062, 0, 3, 0, 0.459491,-99) , 
NN(
0, 
0, 
1.82925, 1, -1, -1, 0.168163,-99) , 
58.3816, 1, 2, 0, 0.417301,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.127406);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0.68057, 0, -1, -1, 0.469096,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.591214,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.218828,-99) , 
51.578, 0, 2, 0, 0.314348,-99) , 
124.723, 1, 0, 0, 0.440996,-99) , 
NN(
0, 
0, 
1.91594, 1, -1, -1, 0.203581,-99) , 
56.7219, 1, 2, 0, 0.402516,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.125678);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.528355,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.317506,-99) , 
0.68057, 0, 1, 0, 0.500908,-99) , 
NN(
0, 
0, 
0.242984, 1, -1, -1, 0.324652,-99) , 
124.723, 1, 0, 0, 0.46958,-99) , 
NN(
0, 
0, 
1.91594, 1, -1, -1, 0.225018,-99) , 
56.7219, 1, 2, 0, 0.430922,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.162821);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.697822,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.454191,-99) , 
35.2971, 1, 11, 0, 0.491098,-99) , 
NN(
0, 
0, 
0.558858, 1, -1, -1, 0.203981,-99) , 
2.53834, 0, 3, 0, 0.460742,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.612559,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.226878,-99) , 
2.79975, 1, 3, 0, 0.42499,-99) , 
NN(
0, 
0, 
2.22606, 1, -1, -1, 0.0276855,-99) , 
52.0588, 1, 2, 0, 0.256515,-99) , 
2.00645, 1, 6, 0, 0.42352,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.146903);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.584558,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.437746,-99) , 
0.587685, 1, 9, 0, 0.519628,-99) , 
NN(
0, 
0, 
0.558858, 1, -1, -1, 0.231693,-99) , 
2.53834, 0, 3, 0, 0.490206,-99) , 
NN(
0, 
0, 
49.4958, 1, -1, -1, 0.261061,-99) , 
2.00645, 1, 6, 0, 0.449673,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.132182);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.55635,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.36326,-99) , 
0.847229, 0, 1, 0, 0.513204,-99) , 
NN(
0, 
0, 
83.648, 1, -1, -1, 0.341557,-99) , 
0.728525, 1, 7, 0, 0.481976,-99) , 
NN(
0, 
0, 
52.0588, 1, -1, -1, 0.239378,-99) , 
2.26807, 1, 6, 0, 0.455327,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.0931638);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.514013,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.362853,-99) , 
124.701, 1, 0, 0, 0.48826,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.166782,-99) , 
3.81423, 0, 8, 0, 0.477098,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.564649,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
122.705, 1, 0, 0, 0.441155,-99) , 
NN(
0, 
0, 
91.6575, 0, 0, -1, 0,-99) , 
1.82925, 1, 6, 0, 0.265693,-99) , 
58.3816, 1, 2, 0, 0.450294,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.107803);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.592732,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.453586,-99) , 
39.277, 1, 4, 0, 0.472828,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.180134,-99) , 
3.81423, 0, 8, 0, 0.462939,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.541625,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
122.705, 1, 0, 0, 0.426975,-99) , 
NN(
0, 
0, 
91.6575, 0, 0, -1, 0,-99) , 
1.82925, 1, 6, 0, 0.260483,-99) , 
58.3816, 1, 2, 0, 0.437794,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.153437);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.61813,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.409219,-99) , 
1.2299, 1, 6, 0, 0.542283,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.521099,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.271993,-99) , 
1.13343, 0, 6, 0, 0.43269,-99) , 
0.312517, 1, 7, 0, 0.482552,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.57022,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.128844,-99) , 
73.0951, 1, 4, 0, 0.410107,-99) , 
NN(
0, 
0, 
91.6575, 0, 0, -1, 0,-99) , 
1.82925, 1, 6, 0, 0.254106,-99) , 
58.3816, 1, 2, 0, 0.454768,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.136842);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.560249,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.279355,-99) , 
2.01136, 1, 6, 0, 0.532333,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.512095,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.283345,-99) , 
82.0941, 1, 4, 0, 0.420428,-99) , 
0.312517, 1, 7, 0, 0.471284,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.578959,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
0.958806, 0, 1, 0, 0.462583,-99) , 
NN(
0, 
0, 
18.5172, 1, -1, -1, 0.0718854,-99) , 
53.7916, 0, 11, 0, 0.250652,-99) , 
58.3816, 1, 2, 0, 0.445188,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.127073);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.5377,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.422442,-99) , 
2.94379, 0, 5, 0, 0.474887,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.613436,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.201831,-99) , 
2.61475, 1, 5, 0, 0.334559,-99) , 
2.57062, 0, 3, 0, 0.454613,-99) , 
NN(
0, 
0, 
1.82925, 1, -1, -1, 0.249317,-99) , 
58.3816, 1, 2, 0, 0.430988,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.111691);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.577987,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.436395,-99) , 
32.9741, 1, 11, 0, 0.464319,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.521505,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
25.0399, 1, 8, 0, 0.285194,-99) , 
2.26807, 1, 6, 0, 0.446584,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.437412,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.119154);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.67881,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.483804,-99) , 
34.2988, 1, 11, 0, 0.507535,-99) , 
NN(
0, 
0, 
0.558858, 1, -1, -1, 0.261652,-99) , 
2.53834, 0, 3, 0, 0.48431,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.616247,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.133115,-99) , 
83.1551, 1, 4, 0, 0.507719,-99) , 
NN(
0, 
0, 
64.5234, 1, -1, -1, 0.0758887,-99) , 
49.4958, 1, 2, 0, 0.309885,-99) , 
1.91924, 1, 6, 0, 0.452146,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.135617);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.557574,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.415323,-99) , 
122.779, 1, 0, 0, 0.530176,-99) , 
NN(
0, 
0, 
0.558858, 1, -1, -1, 0.285315,-99) , 
2.53834, 0, 3, 0, 0.507555,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.587708,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.147476,-99) , 
83.1551, 1, 4, 0, 0.491152,-99) , 
NN(
0, 
0, 
64.5234, 1, -1, -1, 0.0846786,-99) , 
49.4958, 1, 2, 0, 0.308063,-99) , 
1.91924, 1, 6, 0, 0.471609,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0827787);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.515926,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.307251,-99) , 
2.5067, 0, 3, 0, 0.499296,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.491706,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.520026,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.144025,-99) , 
86.9245, 1, 4, 0, 0.442299,-99) , 
NN(
0, 
0, 
2.12138, 1, -1, -1, 0.0392722,-99) , 
52.0588, 1, 2, 0, 0.305843,-99) , 
1.91924, 1, 6, 0, 0.458935,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0795227);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.50148,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.331042,-99) , 
0.68057, 0, 1, 0, 0.481865,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.474821,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.569319,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.279979,-99) , 
30.0587, 1, 8, 0, 0.429647,-99) , 
NN(
0, 
0, 
2.12138, 1, -1, -1, 0.0425174,-99) , 
52.0588, 1, 2, 0, 0.301284,-99) , 
1.91924, 1, 6, 0, 0.444597,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0807567);
  fForest.push_back( 
NN(
0, 
0, 
5.92974, 0, -1, -1, 0.433106,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0565297);
  fForest.push_back( 
NN(
0, 
0, 
5.92974, 0, -1, -1, 0.453031,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0443723);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.502286,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.316756,-99) , 
2.26807, 1, 6, 0, 0.487155,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.479193,-99) , 
NN(
0, 
0, 
2.84528, 0, -1, -1, 0.141275,-99) , 
5.92974, 0, 8, 0, 0.467072,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0778075);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.598315,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.460713,-99) , 
133.649, 0, 4, 0, 0.477856,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.470211,-99) , 
NN(
0, 
0, 
2.84528, 0, -1, -1, 0.146744,-99) , 
5.92974, 0, 8, 0, 0.458774,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0434457);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.505506,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.342781,-99) , 
2.26807, 1, 6, 0, 0.492427,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.484823,-99) , 
NN(
0, 
0, 
2.84528, 0, -1, -1, 0.156757,-99) , 
5.92974, 0, 8, 0, 0.473485,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0417014);
  fForest.push_back( 
NN(
0, 
0, 
66.6803, 1, -1, -1, 0.465305,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0409792);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.505623,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.353086,-99) , 
85.8444, 0, 0, 0, 0.492104,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.18934,-99) , 
3.81423, 0, 8, 0, 0.482904,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.475693,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0591889);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.645399,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.47298,-99) , 
128.37, 0, 8, 0, 0.483664,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.19571,-99) , 
3.81423, 0, 8, 0, 0.475016,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.468059,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0492715);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.513549,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.396856,-99) , 
124.7, 1, 0, 0, 0.494888,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.133981,-99) , 
-6.19395, 0, 8, 0, 0.488001,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.481044,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0533508);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.711941,-99) , 
NN(
0, 
0, 
2.53925, 0, -1, -1, 0.469764,-99) , 
2.09388, 1, 5, 0, 0.479985,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.473298,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0598488);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.638764,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.49086,-99) , 
0.395377, 1, 10, 0, 0.513542,-99) , 
NN(
0, 
0, 
52.3947, 1, -1, -1, 0.381352,-99) , 
1.91924, 1, 6, 0, 0.492178,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.485488,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0541109);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.523771,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.382257,-99) , 
85.8444, 0, 0, 0, 0.511469,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.225255,-99) , 
3.81423, 0, 8, 0, 0.503298,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.496642,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0599222);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.628166,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.488773,-99) , 
35.2971, 1, 11, 0, 0.512048,-99) , 
NN(
0, 
0, 
52.3947, 1, -1, -1, 0.377074,-99) , 
2.00645, 1, 6, 0, 0.492815,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.486458,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0655723);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.604994,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.491795,-99) , 
3.04461, 0, 3, 0, 0.523917,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.50946,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.0733997,-99) , 
52.3947, 1, 2, 0, 0.396777,-99) , 
1.91924, 1, 6, 0, 0.503512,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.497193,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0825285);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.547595,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.396509,-99) , 
0.68057, 0, 1, 0, 0.531076,-99) , 
NN(
0, 
0, 
52.3947, 1, -1, -1, 0.387999,-99) , 
1.91924, 1, 6, 0, 0.508217,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.502026,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0466788);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.518203,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.403532,-99) , 
55.6905, 1, 2, 0, 0.503857,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.161753,-99) , 
-6.19395, 0, 8, 0, 0.497963,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.492115,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0430974);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.696611,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.50207,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.26786,-99) , 
2.53925, 0, 3, 0, 0.480536,-99) , 
2.09388, 1, 5, 0, 0.489551,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.483925,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0482407);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.687426,-99) , 
NN(
0, 
0, 
2.53925, 0, -1, -1, 0.471716,-99) , 
2.09388, 1, 5, 0, 0.480651,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.475238,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0554346);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.526987,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.449428,-99) , 
86.463, 1, 4, 0, 0.497234,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.169745,-99) , 
-6.19395, 0, 8, 0, 0.491696,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.486281,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0411931);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.656851,-99) , 
NN(
0, 
0, 
71.3048, 1, -1, -1, 0.478528,-99) , 
133.921, 0, 8, 0, 0.488734,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.483488,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.0472584);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.520071,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.427423,-99) , 
122.757, 1, 0, 0, 0.503098,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.183801,-99) , 
-6.19395, 0, 8, 0, 0.49785,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.492609,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0614675);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.672694,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.491038,-99) , 
34.2988, 1, 11, 0, 0.511469,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.52389,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.222882,-99) , 
50.0173, 1, 2, 0, 0.414642,-99) , 
1.74483, 1, 6, 0, 0.490668,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.485614,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0767488);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.541166,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.362058,-99) , 
0.68057, 0, 1, 0, 0.523415,-99) , 
NN(
0, 
0, 
82.7962, 1, -1, -1, 0.409789,-99) , 
1.74483, 1, 6, 0, 0.499109,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.494111,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0486831);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.58446,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.480329,-99) , 
124.212, 0, 4, 0, 0.497458,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.248626,-99) , 
3.81423, 0, 8, 0, 0.491084,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.486331,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0367168);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.513664,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.336621,-99) , 
21.2179, 0, 2, 0, 0.505631,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.257831,-99) , 
3.81423, 0, 8, 0, 0.49935,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.494626,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0934721);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.538884,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.2889,-99) , 
0.936159, 1, 7, 0, 0.521057,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.541675,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.274541,-99) , 
82.7962, 1, 4, 0, 0.442132,-99) , 
99.4526, 0, 0, 0, 0.491441,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.486872,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0509455);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.629656,-99) , 
NN(
0, 
0, 
71.3048, 1, -1, -1, 0.467292,-99) , 
133.921, 0, 8, 0, 0.47654,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.472286,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0197512);
  fForest.push_back( 
NN(
0, 
0, 
66.6803, 1, -1, -1, 0.483547,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0238495);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.504479,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.349253,-99) , 
21.2179, 0, 2, 0, 0.497382,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.19636,-99) , 
-6.19395, 0, 8, 0, 0.492735,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.488481,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0356954);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.664038,-99) , 
NN(
0, 
0, 
2.53925, 0, -1, -1, 0.480116,-99) , 
2.09388, 1, 5, 0, 0.487489,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.483328,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0481679);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.530945,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.466466,-99) , 
0.587685, 1, 9, 0, 0.500164,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.205788,-99) , 
-6.19395, 0, 8, 0, 0.495693,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.491533,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0381706);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.514403,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.432966,-99) , 
122.757, 1, 0, 0, 0.499619,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.213772,-99) , 
-6.19395, 0, 8, 0, 0.495331,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.491266,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.068268);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.655993,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.492539,-99) , 
133.678, 0, 4, 0, 0.516346,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.529722,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.297529,-99) , 
82.7962, 1, 4, 0, 0.444556,-99) , 
99.4526, 0, 0, 0, 0.489477,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.485532,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0682077);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.540359,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.262766,-99) , 
21.2205, 0, 2, 0, 0.528493,-99) , 
NN(
0, 
0, 
52.5566, 1, -1, -1, 0.439627,-99) , 
99.4526, 0, 0, 0, 0.495325,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.491454,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0626958);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.577086,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.483347,-99) , 
32.9741, 1, 11, 0, 0.501784,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.633539,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
25.0399, 1, 8, 0, 0.377008,-99) , 
2.26807, 1, 6, 0, 0.491887,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.48816,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0644469);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.647566,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.498412,-99) , 
0.395377, 1, 10, 0, 0.521392,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.583249,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.307018,-99) , 
24.4029, 1, 8, 0, 0.422486,-99) , 
1.74483, 1, 6, 0, 0.500403,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.496718,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.132283);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.659204,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.493515,-99) , 
0.944609, 1, 1, 0, 0.58484,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.60826,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.42552,-99) , 
3.045, 0, 3, 0, 0.487466,-99) , 
51.8684, 1, 11, 0, 0.529782,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.598581,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.208915,-99) , 
86.91, 1, 4, 0, 0.531829,-99) , 
NN(
0, 
0, 
0.917284, 0, -1, -1, 0.225411,-99) , 
49.4958, 1, 2, 0, 0.418406,-99) , 
1.74483, 1, 6, 0, 0.506128,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.127494);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.588802,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.44611,-99) , 
69.4381, 1, 11, 0, 0.554556,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.386905,-99) , 
0.736123, 0, 1, 0, 0.53473,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.629009,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.341259,-99) , 
2.80977, 1, 5, 0, 0.5103,-99) , 
NN(
0, 
0, 
0.917284, 0, -1, -1, 0.249342,-99) , 
49.4958, 1, 2, 0, 0.414882,-99) , 
1.74483, 1, 6, 0, 0.509536,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0282039);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
97.2797, 0, -1, 1, 0.513577,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.510107,-99) , 
NN(
0, 
0, 
2.84528, 0, -1, -1, 0.248682,-99) , 
5.92974, 0, 8, 0, 0.502723,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.132882);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.578361,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.463661,-99) , 
0.545147, 0, 10, 0, 0.541171,-99) , 
NN(
0, 
0, 
0.674961, 1, -1, -1, 0.381105,-99) , 
0.763183, 1, 7, 0, 0.520717,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.714878,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.322917,-99) , 
27.2446, 1, 8, 0, 0.503966,-99) , 
NN(
0, 
0, 
0.434855, 1, -1, -1, 0.201979,-99) , 
82.5977, 1, 4, 0, 0.42114,-99) , 
1.65762, 1, 6, 0, 0.496161,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0277507);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.661193,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.495559,-99) , 
97.2797, 0, 11, 0, 0.504823,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.501491,-99) , 
NN(
0, 
0, 
2.84528, 0, -1, -1, 0.242956,-99) , 
5.92974, 0, 8, 0, 0.494305,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0347299);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.591858,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.494931,-99) , 
124.212, 0, 4, 0, 0.510989,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.507661,-99) , 
NN(
0, 
0, 
2.84528, 0, -1, -1, 0.248096,-99) , 
5.92974, 0, 8, 0, 0.500493,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0566032);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.5365,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.45531,-99) , 
0.725171, 1, 10, 0, 0.516805,-99) , 
NN(
0, 
0, 
107.251, 0, 0, -1, 0,-99) , 
66.6803, 1, 2, 0, 0.513495,-99) , 
NN(
0, 
0, 
2.84528, 0, -1, -1, 0.254631,-99) , 
5.92974, 0, 8, 0, 0.506403,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0525193);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.603533,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.498267,-99) , 
0.395377, 1, 10, 0, 0.514135,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.511253,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.698686,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
99.2628, 1, 4, 0, 0.579032,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.354782,-99) , 
2.26807, 1, 6, 0, 0.499839,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0728941);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.531242,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.358782,-99) , 
21.2034, 0, 2, 0, 0.523326,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.520466,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.687515,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
99.2628, 1, 4, 0, 0.571338,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.351879,-99) , 
2.26807, 1, 6, 0, 0.508364,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.06002);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.564283,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.487185,-99) , 
50.9357, 0, 2, 0, 0.5068,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.504125,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.675907,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
54.9834, 1, 2, 0, 0.560336,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.347674,-99) , 
2.26807, 1, 6, 0, 0.493124,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0699787);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.538742,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.469532,-99) , 
43.847, 0, 8, 0, 0.51419,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.511552,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.663663,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
99.2628, 1, 4, 0, 0.551175,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.344126,-99) , 
2.26807, 1, 6, 0, 0.49998,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.0639227);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.532132,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.469938,-99) , 
99.4526, 0, 0, 0, 0.509132,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.506605,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.652982,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
54.9834, 1, 2, 0, 0.540237,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.33983,-99) , 
2.26807, 1, 6, 0, 0.495295,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0580046);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.519831,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.441082,-99) , 
0.788236, 1, 9, 0, 0.504983,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.502551,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.638862,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
99.2628, 1, 4, 0, 0.530189,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.335826,-99) , 
2.26807, 1, 6, 0, 0.491437,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0561956);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.557625,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.481165,-99) , 
32.9741, 1, 11, 0, 0.495946,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.493623,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.62992,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
54.9834, 1, 2, 0, 0.520866,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.332062,-99) , 
2.26807, 1, 6, 0, 0.483018,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0589939);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.539107,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.47755,-99) , 
0.277856, 1, 7, 0, 0.504568,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.502267,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.617067,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
99.2628, 1, 4, 0, 0.511813,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.328359,-99) , 
2.26807, 1, 6, 0, 0.491017,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0444505);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.579707,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.49342,-99) , 
0.395377, 1, 10, 0, 0.50638,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.504135,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.607754,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
54.9834, 1, 2, 0, 0.502121,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.324342,-99) , 
2.26807, 1, 6, 0, 0.492675,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.0541245);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.521963,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.402061,-99) , 
22.7682, 0, 2, 0, 0.514164,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.511933,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.597109,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
54.9834, 1, 2, 0, 0.494833,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.321285,-99) , 
2.26807, 1, 6, 0, 0.499918,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0338237);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.635656,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.496256,-99) , 
2.15169, 1, 5, 0, 0.5024,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.500276,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.587692,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
99.2628, 1, 4, 0, 0.485811,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.317458,-99) , 
2.26807, 1, 6, 0, 0.488903,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0389631);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.572127,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.497231,-99) , 
124.212, 0, 4, 0, 0.510113,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.507992,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.579473,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
99.2628, 1, 4, 0, 0.480181,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.315044,-99) , 
2.26807, 1, 6, 0, 0.49609,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0404479);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0.835103, 0, -1, 1, 0.516512,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.514404,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.572383,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
54.9834, 1, 2, 0, 0.473624,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.312208,-99) , 
2.26807, 1, 6, 0, 0.502049,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0330677);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.602118,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.497729,-99) , 
0.835103, 0, 10, 0, 0.506405,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.504379,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.563376,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
99.2628, 1, 4, 0, 0.466806,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.309231,-99) , 
2.26807, 1, 6, 0, 0.492567,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.054537);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.527146,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.458709,-99) , 
0.847229, 0, 1, 0, 0.513302,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.511282,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.557015,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
54.9834, 1, 2, 0, 0.461196,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.306759,-99) , 
2.26807, 1, 6, 0, 0.498997,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0424995);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.513993,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.423807,-99) , 
2.53883, 0, 3, 0, 0.505195,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.503257,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.546152,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
99.2628, 1, 4, 0, 0.451905,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.302621,-99) , 
2.26807, 1, 6, 0, 0.491345,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0350906);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.622291,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.490854,-99) , 
2.15169, 1, 5, 0, 0.496641,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.494775,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.536384,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
54.9834, 1, 2, 0, 0.444656,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.299353,-99) , 
2.26807, 1, 6, 0, 0.483278,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0444628);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.516366,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.443213,-99) , 
124.722, 1, 0, 0, 0.504643,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.502779,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.529639,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
99.2628, 1, 4, 0, 0.438635,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.296612,-99) , 
2.26807, 1, 6, 0, 0.49074,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0423791);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.512384,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.450128,-99) , 
0.725171, 1, 10, 0, 0.497088,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.495291,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.520047,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
54.9834, 1, 2, 0, 0.431002,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.293102,-99) , 
2.26807, 1, 6, 0, 0.483589,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0424772);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.58447,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.483369,-99) , 
0.835103, 0, 10, 0, 0.491693,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.489951,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.51124,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
99.2628, 1, 4, 0, 0.423706,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.289709,-99) , 
2.26807, 1, 6, 0, 0.478457,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0292042);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.605234,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.494456,-99) , 
2.3488, 1, 3, 0, 0.500563,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.498825,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.502086,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
54.9834, 1, 2, 0, 0.416387,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.286269,-99) , 
2.26807, 1, 6, 0, 0.486722,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0374938);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.513638,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.411601,-99) , 
22.7682, 0, 2, 0, 0.50706,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.505326,-99) , 
NN(
0, 
0, 
27.2915, 1, -1, -1, 0.28388,-99) , 
2.26807, 1, 6, 0, 0.492787,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0396087);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.612787,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.503341,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.317814,-99) , 
92.67, 1, 8, 0, 0.489826,-99) , 
133.921, 0, 8, 0, 0.49722,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.504899,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
99.2628, 1, 4, 0, 0.420461,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.291564,-99) , 
2.26807, 1, 6, 0, 0.485656,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0525242);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.603348,-99) , 
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.506954,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.398127,-99) , 
63.9374, 1, 11, 0, 0.481355,-99) , 
133.921, 0, 8, 0, 0.488665,-99) , 
NN(
0, 
0, 
27.2915, 1, -1, -1, 0.288234,-99) , 
2.26807, 1, 6, 0, 0.477475,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.0471161);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.511102,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.458415,-99) , 
0.537548, 1, 9, 0, 0.482971,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.48131,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.510324,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
54.9834, 1, 2, 0, 0.426366,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.299129,-99) , 
2.26807, 1, 6, 0, 0.471229,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0445494);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.50465,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.451879,-99) , 
1.32323, 1, 6, 0, 0.483749,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0,-99) , 
66.6332, 1, 2, 0, 0.482122,-99) , 
NN(
NN(
NN(
0, 
0, 
0, 1, -1, 1, 0.583905,-99) , 
NN(
0, 
0, 
0, 1, -1, -1, 0.209329,-99) , 
0.586145, 1, 10, 0, 0.418113,-99) , 
NN(
0, 
0, 
101.413, 0, 0, -1, 0,-99) , 
27.2915, 1, 8, 0, 0.295043,-99) , 
2.26807, 1, 6, 0, 0.471856,-99)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
